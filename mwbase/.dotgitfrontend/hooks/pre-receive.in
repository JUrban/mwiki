#!/usr/bin/perl -w

use strict;
use warnings;
use File::Temp qw/ tempdir /;
use Carp;
use Cwd;

sub pr_pad {
  my $str = shift;
  return ("[pre-receive] $str");
}

# I think there's a slicker way to do this, using output filters, but
# for now let's just do this as a subroutine.
sub pr_print {
  my $str = shift;
  chomp ($str); # in case it already had some extra whitespace at the end
  print (pr_pad ($str . "\n"));
  return;
}

sub pr_die {
  pr_print(@_);
  exit 1;
}

# named wrappers for the git ls-tree -l -r contents
use constant MODE => 0;
use constant TYPE => 1;
use constant SHA1 => 2;
use constant SIZE => 3;

# admin mode for updating non-library files
my $admin_mode = 0;

# Return a hashref with files as keys and their git -ls-tree -r description as values.
# TODO: move to mw_common.pm
sub git_tree_contents
{
    my $tree = shift;
    my %res  = ();
    my @lines = `git ls-tree -l -r $tree`;
    foreach my $_ (@lines)
    {
	m/^([^\t ]+) +([^\t ]+) +([^\t ]+) +([^\t ]+)[\t](.*)$/ or pr_die("Bad git ls-tree -r line for $tree: $_"); 
	$res{$5} = [$1,$2,$3,$4]; # mode, blob, sha1, size
    }
    return \%res;
}

# Return a hash of all touched (new, deleted, changed) files between old and new trees,
# and separate hashes for new, deleted, and changed files.
sub git_touched_files
{
    my ($old, $new) = @_;
    my %res = %new = %mod = %del = ();
    foreach my $k (keys %$new)
    {
	if(!(exists $old->{$k}))
	{
	    $res{$k} = 'N'; $new{$k} = ();
	}
	elsif(($old->{$k}->[SHA1] != $new->{$k}->[SHA1])
	      || ($old->{$k}->[MODE] != $new->{$k}->[MODE]))
	{
	    $res{$k} = 'M'; $mod{$k} = ();
	}
    }
    foreach my $k (keys %$old)
    {
	if(!(exists $new->{$k})) { $res{$k} = 'D'; $del{$k} = ();
    }
    return (\%res, \%new, \%mod, \%del);
}

# There should be exactly one line given to this script by git.
my $first_line = <>;
my $second_line = <>;
unless (defined $first_line) {
  pr_die ('Standard input was empty!  How is that possible?');
}
if (defined $second_line) {
  pr_die ('We currently handle pushes to only one refspec (namely, the master branch)');
}

# Ensure that the line we've received has the right form, as specified
# in the git man page githooks:
#
# <old-value> SP <new-value> SP <ref-name> LF
chomp $first_line;
my ($old_sha, $new_sha, $refspec) = split (/\ /x, $first_line);
unless (defined $old_sha && defined $new_sha && defined $refspec) {
  pr_die ('The given line does not match the format specified in the githooks(5) man page');
}

# Check for sane SHA1 values
unless ($old_sha =~ /[a-z0-9]{40}/x && $new_sha =~ /[a-z0-9]{40}/x) {
  pr_die ('Suspicious SHA1 values given');
}

# Ensure that the new SHA1 and the old SHA1 are the names of commit
# objects.
my $old_sha_type = `git cat-file -t $old_sha`;
my $new_sha_type = `git cat-file -t $new_sha`;
chomp $old_sha_type;
chomp $new_sha_type;
unless ($old_sha_type eq 'commit') {
  pr_print ("The old object with the name,");
  pr_print ("  $old_sha");
  pr_die ("is not a commit; unable to proceed.");
}
unless ($new_sha_type eq 'commit') {
  pr_print ("The new object with the name,");
  pr_print ("  $new_sha");
  pr_die ("is not a commit; unable to proceed.");
}

# We permit pushes only to the refpsec "refs/heads/master".
unless ($refspec eq 'refs/heads/master') {
  pr_die ('We permit pushes only to the master branch');
}

# Now that we know that the SHA1 object names being pushed are
# commits, find their associated trees
my $old_commit_tree = `git cat-file commit $old_sha | grep ^tree | cut -f 2 -d ' '`;
my $new_commit_tree = `git cat-file commit $new_sha | grep ^tree | cut -f 2 -d ' '`;
chomp $old_commit_tree;
chomp $new_commit_tree;

my $mizar_article_ext = 'miz';
my $coq_article_ext = 'v';
my $article_ext = $mizar_article_ext;
my $article_regexp = '\.$article_ext\$';

# Other file extensions that we have to allow.
my $mizar_special_ext = 'voc';
my $special_ext = $mizar_special_ext;
my $special_regexp = '\.$special_ext\$';

my $old_tree_files = git_tree_contents($old_commit_tree);
my $new_tree_files = git_tree_contents($new_commit_tree);

my ($touched_files, $new_files, $updated_files, $deleted_files)
    = git_touched_files($old_commit_tree, $new_commit_tree);

# Ensure that no non-mizar code is being pushed by non-admins

my @non_lib_files = grep(!/\.($article_ext|$special_ext)\$/, keys %$touched_files);

if ((scalar @non_lib_files > 0) && ($admin_mode == 0)) {
    pr_print ("You need to ask an administrator to change, add, and delete non-library files.");
    pr_print ("Only .$article_ext and .$special_ext files are permitted to be changed, added, and deleted:");
    pr_print(join(', ', @non_lib_files));
    pr_die("  Sorry.");
}

# Ensure that all .miz files satisfy these conditions:
#
# 1 they are under the mml subdirectory
# 2 they are actually files, i.e., blobs in git terminology
# 3 their size is less than, say, one megabyte;
# 4 they have mode 644 ("should never happen", given condition #2)

# Using git show is wrong here: in only lists the files touched by the last commit.
# We need all files touched by the commits that are being pushed.
# Instead we need git ls-tree -r $new_commit_tree, compare with the old tree (by sha1),
# and from that get the updated, new, and deleted articles.
# Why don't we just copy the whole new tree to the backend repo?
# Probably because we do not want to touch those files without a reason so that the re-verification is fast?
# By looking at the sha1, we can avoid trivial re-verifications, and breaking of the btrfs sharing.
# In some sense, this emulates the Scons use of MD5 instead of mtimes.


my @lib_files = grep(/\.$article_ext\$/, keys %$touched_files);
#`git show --name-only --pretty=oneline $new_sha | tail -n +2 | grep "\.$article_ext\$"`;
for my $lib_file (@lib_files) {
  chomp $lib_file;
  if ($lib_file !~ /\A mml \/ ([a-z0-9_]+\.miz) \z/xm) { # strip "mml/" prefix
    pr_print ("Suspicious: .$article_ext file is not under the mml subdirectory");
    pr_die ("The path is $lib_file");
  }
}

my @dict_files = grep(/\.$special_ext\$/, keys %$touched_files);
# `git show --name-only --pretty=oneline $new_sha | tail -n +2 | grep "\.$special_ext\$"`;
for my $lib_file (@dict_files) {
  chomp $lib_file;
  if ($lib_file !~ /\A dict \/ ([a-z0-9_]+\.voc) \z/xm) { # strip "mml/" prefix
    pr_print ("Suspicious: .$special_ext file is not under the dict subdirectory");
    pr_die ("The path is $lib_file");
  }
}

# these are all touched library files (also deleted)
@lib_files = (@lib_files, @dict_files);


# check the new and changed files
for my $lib_file (@lib_files) {
  if (!(exists $deleted_files->{$lib_file}))
  {
      my ($mode, $type, $sha1, $size) = @{$new_commit_tree->{$lib_file}};
      pr_die ("Suspicious: the file $lib_file is bigger than one megabyte: $size")
	  if($size > 1000000);

      pr_die ("Suspicious: a file $lib_file is being commited with mode $mode; we permit only mode 100644")
	  if ($mode ne '100644');

      pr_die ("The file $lib_file is somehow not a git blob object: $type")
	  if ($type eq 'blob');
  }
}

# Now let's try to commit these files to the backend repo.  First, we
# need to store them somewhere.  They are already on the server as
# objects.  I suppose we could just directly copy the files, using the
# SHA1 object names.

my $backend_repo_path = '@@BACKEND@@';

my $wikilock;

# TODO: we should rather be locking the current clone here 
#       - but maybe that's what we do by locking inside $backend_repo_path

# locking taken from ikiwiki
sub lockwiki () {
	# Take an exclusive lock on the wiki to prevent multiple concurrent
	# run issues. The lock will be dropped on program exit.
	open($wikilock, '>', $backend_repo_path . "/" . ".wikilock") ||
	    pr_die ("The wiki cannot write to the lock file $backend_repo_path/.wikilock: $!");
	if (! flock($wikilock, 2|4)) { # LOCK_EX | LOCK_NB
		pr_die("The wiki is being used for another commit, try again in a minute: failed to get lock");
	}
	return 1;
}

sub unlockwiki () {
	return close($wikilock) if $wikilock;
	return;
}


my @new_files = sort keys %$new_files;
my @updated_files = sort keys %$updated_files;
my @deleted_files = sort keys %$deleted_files;


# pr_print ("Here is the list of all received files: @lib_files");

sub pr_print_list  { if (scalar @_ == 0) { pr_print ("(none)"); } else { pr_print ("@_"); }}

pr_print ("Brand new files: ");
pr_print_list (@new_files);
pr_print ("Files to be updated: ");
pr_print_list (@updated_files);
pr_print ("Files to be deleted: ");
pr_print_list (@deleted_files);


lockwiki();

# Now that we've moved the files that are updated in this
# proposed commit to a safe purgatory, copy the contents of the 
# new files to the backend repo.
foreach my $received_file (@lib_files) {
  chomp $received_file;
  ($received_file =~ /^(mml|dict)\/[a-z0-9_]+[.]($article_ext|$special_ext)$/) or
    pr_die("Wrong file name: $received_file");
  my $possibly_new_dir_path = $1;
  `mkdir -p $backend_repo_path/$possibly_new_dir_path`;
  my $received_path = $backend_repo_path . "/" . $received_file;
  `git cat-file blob $new_commit_tree:$received_file > $received_path`;
  unless (-e $received_path) {
    croak ("We didn't output anything to $received_path");
  }
}


## NOTE: we should also think of this in pre-commit


# All changes are now done in the backend
# repo.  Now we commit them.
local $ENV{GIT_DIR} 
  = $backend_repo_path . "/" . ".git"; # GIT_DIR is set to "." by git

chdir $backend_repo_path;              # before executing this hook!

# Let's commit, adding new files and deleting old ones.
my $git_commit_output 
  = system ("git commit -a -m 'Wikifying a remote push' 2>&1");
my $git_commit_exit_code = ($? >> 8);
unless ($git_commit_exit_code == 0) {
  pr_print ("Error commiting to the backend repository:");
  pr_print ("The exit code was $git_commit_exit_code");

  system ("git reset --hard 2>&1");

  exit 1;
}

unlockwiki();

# If we made it this far, then we deserve a break.
exit 0;

; -*- mode: org; -*-
* DONE Set up some perl tests
  As things stand now, I am testing this code by doing a lot of manual
  changes.  Setting up perl tests would help to make this process more
  intelligent, and quicker, too.
* DONE Generate a JFM-like front page
  The post-commit hook seems like the right place to do that.
* TODO Create the "stable" branch in the repo
  Periodically commit there the official releases, possibly
  import there couple of previos versions. Present it in HTML in
  another sandbox.
* TODO Add the check for @proof in pre-commit
  We should forbid theorems with @proof at the master repo. Check it
  using the XML created by article - there should be no element "SkippedProof" 
* TODO Add better error messages
  When we do not commit, show people a log of the pre-commit check,
  and improve the pre-commit/make to tell the errors
* TODO Create the "frontend" repo(s), for anonymous pushes
  As a post-receive hook, changed .miz (different from master) files
  get copied to our master repo, and commit is attempted there. The
  result is announced to the pusher by the post-receive
  hook. Typically, pushers get their own branch, and can decide to
  work with particular branch. The frontend shouls probably track the
  master and stable. Take from ikiwiki its protection against evil
  pushers.


  Here is how I am thinking about doing this.  We have a user, git, on
  the server that actually does the git commands on the server.  The
  question then is how to ensure that anonymous users are able to do
  this.  OK, they use the git protocol on the server.  They suggest
  that this is sufficient.  Anonymous users can then push.  But that
  conflicts, I think, with the git book discussion of the git method.
  OK, maybe this could work.  We've got a git user on the server, and
  people push to a certain directory.  Seems fine.  We just need to
  publish the exact file name to which users push their changes, e.g.:

  git@mws.cs.ru.nl:/home/git/mizarwiki

  That should be fine.  I suppose in principle that's already
  available and we can test it.  We just need an update hook.
  (ikiwiki uses a pre-receive hook.  I'm not sure I understand the
  difference between these two approaches.)  The ikiwiki documentation
  suggests that some more is needed.  In any case, both the ikiwiki
  documentation and the pro git book say that the server repo to which
  people are allowed to push needs to be a bare repo.  But we don't
  have any bare repos yet.  We just have the central repo.

  I need some way to test this on my machine.  We need some sane
  mechanism for installing this software. I'd like to test it both on
  my MacBook Pro and my new little eeepc, as well as my Portuguese
  server.

* TODO Track the master and stable on GitHub.x
  Just by post-commit hooks probably.
* TODO Think if we really need the frontend repo
  We might be fine with just one, OTOH, ikiwiki also uses two repos,
  and we would have to investigate the pre-receive hook for handling
  bad pushes, and not be able to save incorrect work. This is what
  frontend might be useful for.
* TODO Create an "edit" button, and the correspondin cgi
  like in ikiwiki. This gets directly commited in the master, and on
  success, the page is updated. Otherwise, errors are shown to the
  user. We might save his work in some branch or frontend, and let him
  fix his bugs there. This means that we might want to publish the
  list of current branches.
* TODO Create the edit button for sections
  initially for theorems. If just the proof gets edited, don't
  reverify the other articles, just this one. Create dependencies
  among theorems, and try to have the re-verification finer.
* TODO Investigate using SCons or Waf instead of make
  See http://www.scons.org/doc/0.98.5/HTML/scons-user/c779.html . With
  SCons, we can specify the fucntion for decideing if a file has
  changed or not. It can be MD5, but also our own function, saying
  e.g. that the properly stripped XML has not changed. SCons will not
  rebuild after this.
* TODO Create the "clone" button
  and give people a way how to clone things and push to the frontend
* TODO Implement proper locking, of the repos and sandboxes
  Especially wrt to the online editing, because pushes and commits to
  frontends and master probably can rely on git's locking.
* TODO Think of handling mutually incompatible, but correct, developments
  This would be probably multiple branches on the master repo, and
  multiple sandboxes. This is not what Wikipedia allows, but Linux
  does.
* TODO Plug-in the parallelizer
  for faster verification and htmlization of one or two articles only.
* TODO Plug-in more mizar utilities
  can be used as critics of the code
* TODO Plug-in the ATP and AI stuff, and MML Query, and FM
  from my recent atp paper, Grzegorz's developments, etc
* TODO Plug-in the Wikipedia tagging
  provide some suitable metadata and syntax in .miz, provide
  presentation alongside Wikipedia
* TODO Do this for Coq and Isabelle if they give us the tools
  When things are reasonably polished, working fast, and useful at
  least for one PA, and others get motivated to actually give us the
  corresponding tools and work with us on their plugging-in and
  use. Without good testers and developers, it is not going to work.

#!/usr/bin/perl -w

use strict;
use warnings;
use File::Temp qw/ tempfile tempdir /;
use File::Copy;
use File::Basename;
use Cwd;
use Carp;

use mizar;

# Compute list of mizar files that belong to the index (i.e., the
# mizar files that are about to be committed). git diff-index will
# give a list of changed files.  We compare the index to HEAD, the
# most recent commit known to be valid/coherent.  The actual file name
# is the second field of the line (where the field separator is tab),
# hence the first call to "cut -f 2".  The last cut gives us
# "polyform" from "polyform.miz".
my @miz_changed 
  = `git diff-index --cached HEAD | cut -f 2 | grep '\.miz\$'`;
my @non_miz_changed 
  = `git diff-index --cached HEAD | cut -f 2 | grep --invert-match '\.miz\$'`;

my @mml_changed = ();
my @non_mml_changed = ();

sub separate_mml_from_non_mml {
  foreach my $edited (@miz_changed) {
    chomp ($edited);
    my ($name, $path, $extension) = fileparse ($edited, qr/\.[^.]+/);
    if ($path eq "mml/") {
      if (mizar::belongs_to_mml ($name)) {
	push (@mml_changed, $name);
      } else {
	push (@non_mml_changed, $name);
      }
    } else {
      carp ("You're committing a mizar file ($edited) outside the MML subdirectory; we don'handle this case yet");
    }
  }
}

separate_mml_from_non_mml ();

my @new_articles = (@mml_changed, @non_mml_changed);

print ("Here are the changes to the MML:\n");
foreach my $mml (@mml_changed) {
  print ($mml);
  print ("\n");
}

print ("Here are the changes outside the MML:\n");
foreach my $non_mml (@non_mml_changed) {
  print ($non_mml);
  print ("\n");
}

my $git_dir = $ENV{GIT_DIR};
my $working_directory = dirname ($git_dir);
my $temp_mizfiles = mizar::sparse_MIZFILES_in_tempdir ();
print ("Setting MIZFILES to $temp_mizfiles\n");
mizar::set_MIZFILES ($temp_mizfiles);
my $temp_mml = $temp_mizfiles . "/" . "mml";
foreach my $changed (@mml_changed) {
  unless (-e "$working_directory/mml/$changed.miz") {
    croak ("WTF? $working_directory/mml/$changed.miz doesn't exist.  What directory are we doing this in?");
  }
  copy ("$working_directory/mml/$changed.miz", $temp_mml)
    or croak ("Something went wrong copying $changed to $temp_mml: $!");
}

my $admissible_commit = 0;

# Now that we've called envget on the new articles, we can compute
# their dependencies.

my $num_mml_changed = scalar (@mml_changed);
my $num_non_mml_changed = scalar (@non_mml_changed);
my $num_new_articles = scalar (@new_articles);
my $new_articles_as_str = join (" ", @new_articles);
print ("About to call the dependency generator with the argument:\n$new_articles_as_str\n");
my $dependency_makefile
  = `MIZFILES=$temp_mizfiles /Users/alama/sources/mizar/mwiki/dependencies.pl --makefile --proper $new_articles_as_str`;
my $dependency_makefile_converse
  = `MIZFILES=$temp_mizfiles /Users/alama/sources/mizar/mwiki/dependencies.pl --makefile --proper --converse $new_articles_as_str`;
print "Dependency makefile:\n$dependency_makefile\n";
print "Converse of dependency makefile:\n$dependency_makefile_converse\n";
my $all_ok = 1;
for (my $i = 0; $i < $num_new_articles && $all_ok; $i++) {
  my $new_article = $new_articles[$i];
  my $mizf_status = mizar::run_mizf ($new_article);
  unless ($mizf_status == 0) {
    $all_ok = 0;
  }
}
$admissible_commit = $all_ok;

if ($admissible_commit) {
  print ("Your changes are admissible\n");
} else {
  print ("Your changes are inadmissible\n");
}

exit ($admissible_commit);

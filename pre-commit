#!/usr/bin/perl -w

use strict;
use warnings;
use File::Temp qw/ tempfile tempdir /;
use File::Copy;
use File::Basename;
use File::Spec;
use Cwd;
use Carp;

use lib '.perl';

use mizar;

# Compute list of mizar files that belong to the index (i.e., the
# mizar files that are about to be committed). git diff-index will
# give a list of changed files.  We compare the index to HEAD, the
# most recent commit known to be valid/coherent.  The actual file name
# is the second field of the line (where the field separator is tab),
# hence the first call to "cut -f 2".  The last cut gives us
# "polyform" from "polyform.miz".
my @miz_changed 
  = `git diff-index --cached HEAD | cut -f 2 | grep '\.miz\$'`;
my @non_miz_changed 
  = `git diff-index --cached HEAD | cut -f 2 | grep --invert-match '\.miz\$'`;

unless (scalar (@non_miz_changed) == 0) {
  warn ("Only .miz files are permitted to be committed.  Sorry dude.");
  exit (1)
}

my @mml_changed = ();
my @non_mml_changed = ();

my $cwd = getcwd ();
my @repo_path_dirs = File::Spec->splitdir ($cwd);
my $repo_name = $repo_path_dirs[$#repo_path_dirs];
my $compiled = $cwd . "/" . "../$repo_name-compiled";
my $sandbox = $cwd . "/" . "../$repo_name-sandbox";
my $sandbox_mml = $sandbox . "/" . "mml";

# Clean the sandbox: force it to be a copy of the known compiled MML.
# We are hoping that this is fairly fast.
warn ("rsync-ing...");
warn ("compiled: $compiled");
warn ("sandbox: $sandbox");
`rsync -a --del $compiled/ $sandbox`;
warn ("rsync-ing complete.");

sub separate_mml_from_non_mml {
  foreach my $edited (@miz_changed) {
    chomp ($edited);
    my ($name, $path, $extension) = fileparse ($edited, qr/\.[^.]+/);
    if ($path eq "mml/") {
      if (mizar::belongs_to_mml ($name)) {
	warn ("Article $name belongs to the MML");
	push (@mml_changed, $name);
      } else {
	warn ("Article $name does not belong to the MML");
	push (@non_mml_changed, $name);
      }
    } else {
      carp ("You're committing a mizar file ($edited) outside the MML subdirectory; we don'handle this case yet");
    }
  }
}

separate_mml_from_non_mml ();

foreach my $article (@mml_changed) {
  my $real_article_path = "$cwd/mml/$article.miz";
  my $sandbox_article_path = "$sandbox_mml/$article.miz";
  copy ($real_article_path, $sandbox_article_path)
    or croak ("You can't copy $real_article_path to $sandbox_article_path!");
}

my $admissible_commit = 0;

# Call the dependency makefile on the new targets

# Set up PATH and MIZBIN

if (!defined ($ENV{"MIZBIN"}) or -z $ENV{"MIZBIN"}) {
  $ENV{"MIZBIN"} = $sandbox . "/bin";
}
$ENV{"PATH"} = $ENV{"PATH"} . ":" . $ENV{"MIZBIN"};

# MAKEJOBS: number of different make jobs to run simultaneously
my $makejobs = 1;
if (defined ($ENV{"MAKEJOBS"})) {
  $makejobs = $ENV{"MAKEJOBS"};
}

chdir ($sandbox_mml);
`MIZFILES=$sandbox make --jobs $makejobs evls deps > make-deps-out 2> make-deps-err`;

unless (-z "$sandbox_mml/make-deps-err") {
  warn ("Something went wrong in compiling the dependencies");
  exit (1);
}

# Now try to verify the new articles

chdir ($sandbox);
`MIZFILES=$sandbox make --jobs $makejobs xmlvrfs > make-xml-out 2> make-xml-err`;

if (-z "$sandbox/make-xml-err") {
  $admissible_commit = 1;
} else {
  warn ("Errors were detected while verifying your changes!");
  $admissible_commit = 0;
}

`MIZFILES=. make --jobs $makejobs prels > make-prel-out 2> make-prel-err`;
if (-z "$sandbox/make-prel-err") {
  $admissible_commit = 1;
} else {
  warn ("Errors were detected while PRELing!");
  $admissible_commit = 0;
}

if ($admissible_commit == 0) {
  print ("Your changes are inadmissible\n");
  exit (1); # i.e., fail
} else {
  print ("Your changes are admissible\n");
  exit (0); # i.e., ok
}

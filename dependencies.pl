#!/usr/bin/perl -w

# Using the env2txt XSL transformation sheet combined with the output
# of envget, compute the list of all dependenceis for the MML.

use strict;
use warnings;
use File::Temp qw/ tempfile tempdir /;
use Cwd;
use Carp qw/ croak /;
use Getopt::Long;

use mizar;

my $tsort_output = 0;
my $makefile_output = 0;
my $do_converse = 0;
my $do_proper = 1;
my $do_full_mml = 0;
my $opt_mizfiles;

GetOptions (
	    "tsort" => \$tsort_output,
	    "makefile" => \$makefile_output,
	    "proper" => \$do_proper,
	    "full-mml" => \$do_full_mml,
	    "converse" => \$do_converse,
	    "with-mizfiles" => \$opt_mizfiles
	   );

my $mizfiles;

if (defined ($opt_mizfiles)) {
  $mizfiles = $opt_mizfiles;
} else {
  $mizfiles = $ENV{"MIZFILES"};
}

unless (scalar (@ARGV) == 0) {
  if (-d $opt_mizfiles) {
    unless (-x $opt_mizfiles) {
      croak ("Unable to write to the given MIZFILES directory, $opt_mizfiles");
    }
  } else {
    croak ("Given MIZFILES directoy, $opt_mizfiles, isn't a directory");
  }
}

# Global variables
my $mml_dir = $mizfiles . "/" . "mml";
my $mml_lar_path = $mizfiles . "/" . "mml.lar";
my $evl2txt = "/Users/alama/sources/mizar/xsl4mizar/evl2txt.xsl";

if (!($tsort_output) && !($makefile_output)) {
  croak ("Either tsort or makefile output format should be specified");
}

if ($tsort_output && $makefile_output) {
  croak ("One cannot specify both tsort and makefile output format");
}

my @articles;
if ($do_full_mml) {
  @articles = mizar::get_MML_LAR ();
} else {
  @articles = @ARGV;
}

# Compute the articles mentioned in mml.lar

my %proper_deps;
my %proper_converse_deps;

my %vocabularies_deps;
my %notations_deps;
my %constructors_deps;
my %registrations_deps;
my %requirements_deps;
my %definitions_deps;
my %theorems_deps;
my %schemes_deps;
my %vocabularies_converse_deps;
my %notations_converse_deps;
my %constructors_converse_deps;
my %registrations_converse_deps;
my %requirements_converse_deps;
my %definitions_converse_deps;
my %theorems_converse_deps;
my %schemes_converse_deps;

sub initialize_all_article_dependencies {
  foreach my $article (@articles) {
    my @article_deps = @{article_dependencies_by_directive ($article)};
    my @article_vocabularies = @{$article_deps[0]};
    my @article_notations = @{$article_deps[1]};
    my @article_constructors = @{$article_deps[2]};
    my @article_registrations = @{$article_deps[3]};
    my @article_requirements = @{$article_deps[4]};
    my @article_definitions = @{$article_deps[5]};
    my @article_theorems = @{$article_deps[6]};
    my @article_schemes = @{$article_deps[7]};
    $vocabularies_deps{$article} = \@article_vocabularies;
    $notations_deps{$article} = \@article_notations;
    $constructors_deps{$article} = \@article_constructors;
    $registrations_deps{$article} = \@article_registrations;
    $requirements_deps{$article} = \@article_requirements;
    $definitions_deps{$article} = \@article_definitions;
    $theorems_deps{$article} = \@article_theorems;
    $schemes_deps{$article} = \@article_schemes;
  }
}

sub initialize_proper_article_dependencies {
  foreach my $article (@articles) {
    my @article_deps = @{article_proper_dependencies ($article)};
    $proper_deps{$article} = \@article_deps;
  }
}

sub article_envget {
  my $article = shift ();
  my $envget_return = mizar::run_envget ($article);
  unless ($envget_return == 0) {
    croak ("Something went wrong running envget on $article!");
  }
}

sub article_evl2txt {
  my $article = shift ();
  article_envget ($article);
  my $article_evl = $mml_dir . "/" . $article . ".evl";
  my $article_dep = $mml_dir . "/" . $article . ".dep";
  unless (-e $article_evl) {
    croak ("The EVL file, $article.evl, doesn't exist under $mml_dir");
  }
  my $xsltproc_exit_status;
  system ("xsltproc", "--output", $article_dep, $evl2txt, $article_evl);
  $xsltproc_exit_status = ($? >> 8);
  unless ($xsltproc_exit_status == 0) {
    # Ditto.
    croak ("xsltproc did not exit cleanly when given $article_evl");
  }
}

sub article_dependencies_by_directive {
  my $article = shift ();
  article_evl2txt ($article);
  # Parse the output from xsltproc generated by applying the evl2txt sheet.
  my ($dep_line, $semi_dep_line_field, $dep_line_field);
  my @dep_line_fields = ();
  my @article_vocabularies = ();
  my @article_notations = ();
  my @article_constructors = ();
  my @article_registrations = ();
  my @article_requirements = ();
  my @article_definitions = ();
  my @article_theorems = ();
  my @article_schemes = ();
  my @article_deps;
  my $article_dep = $article . ".dep";
  my $article_dep_fh;
  open ($article_dep_fh, q{<}, $article_dep)
    or croak ("Unable to open article dependency file $article_dep!");
  while (defined ($dep_line = <$article_dep_fh>)) {
    chomp ($dep_line);
    # there's always a blank line at the end of the file -- yuck
    unless ($dep_line eq "") {
      push (@dep_line_fields, $dep_line);
    }
  }
  close ($article_dep_fh);
  foreach my $dep_line_field (@dep_line_fields) {
    # should look like (e.g.) "(vocabularies ...)".
    # First, delete the trailing ")"
    $dep_line_field = substr ($dep_line_field, 0, -1);
    # New get rid of the initial "(";
    $dep_line_field = substr ($dep_line_field, 1);
    my @dep_line_entries = split (/\ /x,$dep_line_field);
    my $first_element = shift (@dep_line_entries);

    if ($first_element eq "vocabularies") {
      @article_vocabularies = @dep_line_entries;
    }
    
    if ($first_element eq "notations") {
      @article_notations = @dep_line_entries;
    }
    
    if ($first_element eq "constructors") {
      @article_constructors = @dep_line_entries;
    }
    
    if ($first_element eq "registrations") {
      @article_registrations = @dep_line_entries;
    }
    
    if ($first_element eq "requirements") {
      @article_requirements = @dep_line_entries;
    }
    
    if ($first_element eq "definitions") {
      @article_definitions = @dep_line_entries;
    }
    
    if ($first_element eq "theorems") {
      @article_theorems = @dep_line_entries;
    }
    
    if ($first_element eq "schemes") {
      @article_schemes = @dep_line_entries;
    }
  }

  @article_deps = (\@article_vocabularies,
		   \@article_notations,
		   \@article_constructors,
		   \@article_registrations,
		   \@article_requirements,
		   \@article_definitions,
		   \@article_theorems,
		   \@article_schemes);
  return (\@article_deps);
}

sub article_proper_dependencies {
  my $article = shift ();
  # The "proper" dependencies of an article is the union of the
  # contents of all directives EXCEPT vocabularies and requirements.
  article_evl2txt ($article);
  # Parse the output from xsltproc generated by applying the evl2txt sheet.
  my ($dep_line, $semi_dep_line_field, $dep_line_field);
  my @dep_line_fields = ();
  my @article_notations = ();
  my @article_constructors = ();
  my @article_registrations = ();
  my @article_definitions = ();
  my @article_theorems = ();
  my @article_schemes = ();
  my $article_dep = $article . ".dep";
  my $article_dep_path = $mml_dir . "/" . $article_dep;
  my $article_dep_fh;
  open ($article_dep_fh, q{<}, $article_dep_path)
    or croak ("Unable to open article dependency file $article_dep_path!");
  while (defined ($dep_line = <$article_dep_fh>)) {
    chomp ($dep_line);
    # there's always a blank line at the end of the file -- yuck
    unless ($dep_line eq "") {
      push (@dep_line_fields, $dep_line);
    }
  }
  close ($article_dep_fh);
  foreach my $dep_line_field (@dep_line_fields) {
    # should look like (e.g.) "(vocabularies ...)".
    # First, delete the trailing ")"
    $dep_line_field = substr ($dep_line_field, 0, -1);
    # New get rid of the initial "(";
    $dep_line_field = substr ($dep_line_field, 1);
    my @dep_line_entries = split (/\ /x,$dep_line_field);
    my $first_element = shift (@dep_line_entries);

    if ($first_element eq "notations") {
      @article_notations = @dep_line_entries;
    }
    
    if ($first_element eq "constructors") {
      @article_constructors = @dep_line_entries;
    }
    
    if ($first_element eq "registrations") {
      @article_registrations = @dep_line_entries;
    }
    
    if ($first_element eq "definitions") {
      @article_definitions = @dep_line_entries;
    }
    
    if ($first_element eq "theorems") {
      @article_theorems = @dep_line_entries;
    }
    
    if ($first_element eq "schemes") {
      @article_schemes = @dep_line_entries;
    }
  }
  

  # Compute union
  my @article_deps_with_dups = (@article_notations,
				@article_constructors,
				@article_registrations,
				@article_definitions,
				@article_theorems,
				@article_schemes);
  my @article_deps = ();
  my %article_deps_hash = ();
  foreach my $article (@article_deps_with_dups) {
    unless (defined ($article_deps_hash{$article})) {
      push (@article_deps, $article);
      $article_deps_hash{$article} = 0;
    }
  }

  return (\@article_deps);
}

sub converse {
  # Naive quadratic implementation.  Tons of intermediate junk
  # generated along the way.  Does perl have a garbage collector?
  my $relation_ref = shift;
  my %relation = %{$relation_ref};
  my %converse = ();
  my $range_elt;
  foreach my $elt (keys (%relation)) {
    my @range = @{$relation{$elt}};
    foreach my $range_elt (@range) {
      my @domain = ();
      my $range_ref = $converse{$range_elt};
      if (defined ($range_ref)) {
	my @previous_value = @{$range_ref};
	push (@domain, @previous_value);
      }
      push (@domain, $elt);
      $converse{$range_elt} = \@domain;
    }
  }
  return (\%converse);
}

sub compute_proper_converse {
  my $proper_converse_ref = converse (\%proper_deps);
  %proper_converse_deps = %{$proper_converse_ref};
}

sub compute_converses {
  my $vocaularies_converse = converse (\%vocabularies_deps);
  %vocabularies_converse_deps = %{$vocaularies_converse};
  my $notations_converse = converse (\%notations_deps);
  %notations_converse_deps = %{$notations_converse};
  my $constructors_converse = converse (\%constructors_deps);
  %constructors_converse_deps = %{$constructors_converse};
  my $registrations_converse = converse (\%registrations_deps);
  %registrations_converse_deps = %{$registrations_converse};
  my $requirements_converse = converse (\%requirements_deps);
  %requirements_converse_deps = %{$requirements_converse};
  my $definitions_converse = converse (\%definitions_deps);
  %definitions_converse_deps = %{$definitions_converse};
  my $theorems_converse = converse (\%theorems_deps);
  %theorems_converse_deps = %{$theorems_converse};
  my $schemes_converse = converse (\%schemes_deps);
  %schemes_converse_deps = %{$schemes_converse};
}

sub print_tsort_table {
  my $arg = shift ();
  my %table = %{$arg};
  foreach my $key (keys (%table)) {
    my $value = $table{$key};
    my @values = @{$value};
    my $num_values = scalar (@values);
    for (my $i = 0; $i < $num_values; $i++) {
      print ("$key $values[$i]\n");
    }
  }
}

sub print_table {
  my $arg = shift ();
  my %table = %{$arg};
  foreach my $key (keys (%table)) {
    my $value_ref = $table{$key};
    my @values = @{$value_ref};
    my $num_values = scalar (@values);
    print ("$key: ");
    for (my $i = 0; $i < $num_values; $i++) {
      print $values[$i];
      unless ($i == $num_values - 1) {
	print (" ");
      }
    }
    print ("\n");
  }
}

sub print_relations {
  print ("The vocabularies relation:\n");
  print_table (\%vocabularies_deps);
  print ("The notations relation:\n");
  print_table (\%notations_deps);
  print ("The constructors relation:\n");
  print_table (\%constructors_deps);
  print ("The registrations relation:\n");
  print_table (\%registrations_deps);
  print ("The requirements relation:\n");
  print_table (\%requirements_deps);
  print ("The definitions relation:\n");
  print_table (\%definitions_deps);
  print ("The theorems relation:\n");
  print_table (\%theorems_deps);
  print ("The schemes relation:\n");
  print_table (\%schemes_deps);
}

sub print_makefile_proper_dependency_relation {
  print_table (\%proper_deps);
}

sub print_makefile_proper_converse {
  print_table (\%proper_converse_deps)
}

sub print_tsort_proper_dependency_relation {
  print_tsort_table (\%proper_deps);
}

sub print_tsort_converse_dependency_relation {
  print_tsort_table (\%proper_converse_deps);
}

sub print_converses {
  print ("Converse of the vocabularies relation:\n");
  print_table (\%vocabularies_converse_deps);
  print ("Converse of the notations relation:\n");
  print_table (\%notations_converse_deps);
  print ("Converse of the constructors relation:\n");
  print_table (\%constructors_converse_deps);
  print ("Converse of the registrations relation:\n");
  print_table (\%registrations_converse_deps);
  print ("Converse of the requirements relation:\n");
  print_table (\%requirements_converse_deps);
  print ("Converse of the definitions relation:\n");
  print_table (\%definitions_converse_deps);
  print ("Converse of the theorems relation:\n");
  print_table (\%theorems_converse_deps);
  print ("Converse of the schemes relation:\n");
  print_table (\%schemes_converse_deps);
}

if ($do_proper) {
  initialize_proper_article_dependencies ();
} else {
  initialize_all_article_dependencies ();
}

if ($do_converse) {
  if ($do_proper) {
    compute_proper_converse ();
  } else {
    compute_converses ();
  }
}

if ($tsort_output) {
  if ($do_converse) {
    print_tsort_converse_dependency_relation ();
  }  else {
    print_tsort_proper_dependency_relation ();
  }
} else {
  if ($do_proper) {
    if ($do_converse) {
      print_makefile_proper_converse ();
    } else {
      print_makefile_proper_dependency_relation ();
    }
  } else {
    print_relations ();
  }
}
